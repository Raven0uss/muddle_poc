module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Ad {
  id: ID!
  name: String!
  company: String!
  companyIcon: String!
  content: String!
  image: String!
  link: String
  active: Boolean!
  ratio: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdConnection {
  pageInfo: PageInfo!
  edges: [AdEdge]!
  aggregate: AggregateAd!
}

input AdCreateInput {
  id: ID
  name: String!
  company: String!
  companyIcon: String!
  content: String!
  image: String!
  link: String
  active: Boolean
  ratio: Int
}

type AdEdge {
  node: Ad!
  cursor: String!
}

enum AdOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  company_ASC
  company_DESC
  companyIcon_ASC
  companyIcon_DESC
  content_ASC
  content_DESC
  image_ASC
  image_DESC
  link_ASC
  link_DESC
  active_ASC
  active_DESC
  ratio_ASC
  ratio_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AdPreviousValues {
  id: ID!
  name: String!
  company: String!
  companyIcon: String!
  content: String!
  image: String!
  link: String
  active: Boolean!
  ratio: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdSubscriptionPayload {
  mutation: MutationType!
  node: Ad
  updatedFields: [String!]
  previousValues: AdPreviousValues
}

input AdSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdWhereInput
  AND: [AdSubscriptionWhereInput!]
}

type AdTarget {
  id: ID!
  name: String!
  gender: GenderFilter!
  birthdateMin: DateTime!
  birthdateMax: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdTargetConnection {
  pageInfo: PageInfo!
  edges: [AdTargetEdge]!
  aggregate: AggregateAdTarget!
}

input AdTargetCreateInput {
  id: ID
  name: String!
  gender: GenderFilter
  birthdateMin: DateTime!
  birthdateMax: DateTime!
}

type AdTargetEdge {
  node: AdTarget!
  cursor: String!
}

enum AdTargetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  gender_ASC
  gender_DESC
  birthdateMin_ASC
  birthdateMin_DESC
  birthdateMax_ASC
  birthdateMax_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AdTargetPreviousValues {
  id: ID!
  name: String!
  gender: GenderFilter!
  birthdateMin: DateTime!
  birthdateMax: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdTargetSubscriptionPayload {
  mutation: MutationType!
  node: AdTarget
  updatedFields: [String!]
  previousValues: AdTargetPreviousValues
}

input AdTargetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdTargetWhereInput
  AND: [AdTargetSubscriptionWhereInput!]
}

input AdTargetUpdateInput {
  name: String
  gender: GenderFilter
  birthdateMin: DateTime
  birthdateMax: DateTime
}

input AdTargetUpdateManyMutationInput {
  name: String
  gender: GenderFilter
  birthdateMin: DateTime
  birthdateMax: DateTime
}

input AdTargetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  gender: GenderFilter
  gender_not: GenderFilter
  gender_in: [GenderFilter!]
  gender_not_in: [GenderFilter!]
  birthdateMin: DateTime
  birthdateMin_not: DateTime
  birthdateMin_in: [DateTime!]
  birthdateMin_not_in: [DateTime!]
  birthdateMin_lt: DateTime
  birthdateMin_lte: DateTime
  birthdateMin_gt: DateTime
  birthdateMin_gte: DateTime
  birthdateMax: DateTime
  birthdateMax_not: DateTime
  birthdateMax_in: [DateTime!]
  birthdateMax_not_in: [DateTime!]
  birthdateMax_lt: DateTime
  birthdateMax_lte: DateTime
  birthdateMax_gt: DateTime
  birthdateMax_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AdTargetWhereInput!]
}

input AdTargetWhereUniqueInput {
  id: ID
  name: String
}

input AdUpdateInput {
  name: String
  company: String
  companyIcon: String
  content: String
  image: String
  link: String
  active: Boolean
  ratio: Int
}

input AdUpdateManyMutationInput {
  name: String
  company: String
  companyIcon: String
  content: String
  image: String
  link: String
  active: Boolean
  ratio: Int
}

input AdWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  companyIcon: String
  companyIcon_not: String
  companyIcon_in: [String!]
  companyIcon_not_in: [String!]
  companyIcon_lt: String
  companyIcon_lte: String
  companyIcon_gt: String
  companyIcon_gte: String
  companyIcon_contains: String
  companyIcon_not_contains: String
  companyIcon_starts_with: String
  companyIcon_not_starts_with: String
  companyIcon_ends_with: String
  companyIcon_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  active: Boolean
  active_not: Boolean
  ratio: Int
  ratio_not: Int
  ratio_in: [Int!]
  ratio_not_in: [Int!]
  ratio_lt: Int
  ratio_lte: Int
  ratio_gt: Int
  ratio_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AdWhereInput!]
}

input AdWhereUniqueInput {
  id: ID
}

type AggregateAd {
  count: Int!
}

type AggregateAdTarget {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateConnected {
  count: Int!
}

type AggregateConversation {
  count: Int!
}

type AggregateDebate {
  count: Int!
}

type AggregateInteraction {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregateNotification {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateStatistique {
  count: Int!
}

type AggregateTmpUser {
  count: Int!
}

type AggregateTrophy {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  from: User!
  content: String!
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  dislikes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
  debate: Debate!
  createdAt: DateTime!
  updatedAt: DateTime!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  nested: Boolean!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  from: UserCreateOneInput!
  content: String!
  likes: UserCreateManyInput
  dislikes: UserCreateManyInput
  reports: ReportCreateManyWithoutCommentInput
  debate: DebateCreateOneWithoutCommentsInput!
  comments: CommentCreateManyInput
  nested: Boolean
}

input CommentCreateManyInput {
  create: [CommentCreateInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutDebateInput {
  create: [CommentCreateWithoutDebateInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateOneInput {
  create: CommentCreateInput
  connect: CommentWhereUniqueInput
}

input CommentCreateOneWithoutReportsInput {
  create: CommentCreateWithoutReportsInput
  connect: CommentWhereUniqueInput
}

input CommentCreateWithoutDebateInput {
  id: ID
  from: UserCreateOneInput!
  content: String!
  likes: UserCreateManyInput
  dislikes: UserCreateManyInput
  reports: ReportCreateManyWithoutCommentInput
  comments: CommentCreateManyInput
  nested: Boolean
}

input CommentCreateWithoutReportsInput {
  id: ID
  from: UserCreateOneInput!
  content: String!
  likes: UserCreateManyInput
  dislikes: UserCreateManyInput
  debate: DebateCreateOneWithoutCommentsInput!
  comments: CommentCreateManyInput
  nested: Boolean
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  nested_ASC
  nested_DESC
}

type CommentPreviousValues {
  id: ID!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  nested: Boolean!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  nested: Boolean
  nested_not: Boolean
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
}

input CommentUpdateDataInput {
  from: UserUpdateOneRequiredInput
  content: String
  likes: UserUpdateManyInput
  dislikes: UserUpdateManyInput
  reports: ReportUpdateManyWithoutCommentInput
  debate: DebateUpdateOneRequiredWithoutCommentsInput
  comments: CommentUpdateManyInput
  nested: Boolean
}

input CommentUpdateInput {
  from: UserUpdateOneRequiredInput
  content: String
  likes: UserUpdateManyInput
  dislikes: UserUpdateManyInput
  reports: ReportUpdateManyWithoutCommentInput
  debate: DebateUpdateOneRequiredWithoutCommentsInput
  comments: CommentUpdateManyInput
  nested: Boolean
}

input CommentUpdateManyDataInput {
  content: String
  nested: Boolean
}

input CommentUpdateManyInput {
  create: [CommentCreateInput!]
  update: [CommentUpdateWithWhereUniqueNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueNestedInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyMutationInput {
  content: String
  nested: Boolean
}

input CommentUpdateManyWithoutDebateInput {
  create: [CommentCreateWithoutDebateInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutDebateInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutDebateInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateOneInput {
  create: CommentCreateInput
  update: CommentUpdateDataInput
  upsert: CommentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CommentWhereUniqueInput
}

input CommentUpdateOneWithoutReportsInput {
  create: CommentCreateWithoutReportsInput
  update: CommentUpdateWithoutReportsDataInput
  upsert: CommentUpsertWithoutReportsInput
  delete: Boolean
  disconnect: Boolean
  connect: CommentWhereUniqueInput
}

input CommentUpdateWithoutDebateDataInput {
  from: UserUpdateOneRequiredInput
  content: String
  likes: UserUpdateManyInput
  dislikes: UserUpdateManyInput
  reports: ReportUpdateManyWithoutCommentInput
  comments: CommentUpdateManyInput
  nested: Boolean
}

input CommentUpdateWithoutReportsDataInput {
  from: UserUpdateOneRequiredInput
  content: String
  likes: UserUpdateManyInput
  dislikes: UserUpdateManyInput
  debate: DebateUpdateOneRequiredWithoutCommentsInput
  comments: CommentUpdateManyInput
  nested: Boolean
}

input CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateDataInput!
}

input CommentUpdateWithWhereUniqueWithoutDebateInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutDebateDataInput!
}

input CommentUpsertNestedInput {
  update: CommentUpdateDataInput!
  create: CommentCreateInput!
}

input CommentUpsertWithoutReportsInput {
  update: CommentUpdateWithoutReportsDataInput!
  create: CommentCreateWithoutReportsInput!
}

input CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateDataInput!
  create: CommentCreateInput!
}

input CommentUpsertWithWhereUniqueWithoutDebateInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutDebateDataInput!
  create: CommentCreateWithoutDebateInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: UserWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  likes_some: UserWhereInput
  dislikes_some: UserWhereInput
  reports_some: ReportWhereInput
  debate: DebateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  comments_some: CommentWhereInput
  nested: Boolean
  nested_not: Boolean
  AND: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

type Connected {
  id: ID!
  date: DateTime!
  connections(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ConnectedConnection {
  pageInfo: PageInfo!
  edges: [ConnectedEdge]!
  aggregate: AggregateConnected!
}

input ConnectedCreateInput {
  id: ID
  date: DateTime!
  connections: UserCreateManyInput
}

input ConnectedCreateManyInput {
  create: [ConnectedCreateInput!]
  connect: [ConnectedWhereUniqueInput!]
}

type ConnectedEdge {
  node: Connected!
  cursor: String!
}

enum ConnectedOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConnectedPreviousValues {
  id: ID!
  date: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ConnectedScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConnectedScalarWhereInput!]
  OR: [ConnectedScalarWhereInput!]
  NOT: [ConnectedScalarWhereInput!]
}

type ConnectedSubscriptionPayload {
  mutation: MutationType!
  node: Connected
  updatedFields: [String!]
  previousValues: ConnectedPreviousValues
}

input ConnectedSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConnectedWhereInput
  AND: [ConnectedSubscriptionWhereInput!]
}

input ConnectedUpdateDataInput {
  date: DateTime
  connections: UserUpdateManyInput
}

input ConnectedUpdateInput {
  date: DateTime
  connections: UserUpdateManyInput
}

input ConnectedUpdateManyDataInput {
  date: DateTime
}

input ConnectedUpdateManyInput {
  create: [ConnectedCreateInput!]
  update: [ConnectedUpdateWithWhereUniqueNestedInput!]
  upsert: [ConnectedUpsertWithWhereUniqueNestedInput!]
  delete: [ConnectedWhereUniqueInput!]
  connect: [ConnectedWhereUniqueInput!]
  set: [ConnectedWhereUniqueInput!]
  disconnect: [ConnectedWhereUniqueInput!]
  deleteMany: [ConnectedScalarWhereInput!]
  updateMany: [ConnectedUpdateManyWithWhereNestedInput!]
}

input ConnectedUpdateManyMutationInput {
  date: DateTime
}

input ConnectedUpdateManyWithWhereNestedInput {
  where: ConnectedScalarWhereInput!
  data: ConnectedUpdateManyDataInput!
}

input ConnectedUpdateWithWhereUniqueNestedInput {
  where: ConnectedWhereUniqueInput!
  data: ConnectedUpdateDataInput!
}

input ConnectedUpsertWithWhereUniqueNestedInput {
  where: ConnectedWhereUniqueInput!
  update: ConnectedUpdateDataInput!
  create: ConnectedCreateInput!
}

input ConnectedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  connections_some: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConnectedWhereInput!]
}

input ConnectedWhereUniqueInput {
  id: ID
}

type Conversation {
  id: ID!
  speakers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  deleted: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ConversationConnection {
  pageInfo: PageInfo!
  edges: [ConversationEdge]!
  aggregate: AggregateConversation!
}

input ConversationCreateInput {
  id: ID
  speakers: UserCreateManyWithoutConversationsInput
  messages: MessageCreateManyWithoutConversationInput
  deleted: String
}

input ConversationCreateManyWithoutSpeakersInput {
  create: [ConversationCreateWithoutSpeakersInput!]
  connect: [ConversationWhereUniqueInput!]
}

input ConversationCreateOneWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput
  connect: ConversationWhereUniqueInput
}

input ConversationCreateWithoutMessagesInput {
  id: ID
  speakers: UserCreateManyWithoutConversationsInput
  deleted: String
}

input ConversationCreateWithoutSpeakersInput {
  id: ID
  messages: MessageCreateManyWithoutConversationInput
  deleted: String
}

type ConversationEdge {
  node: Conversation!
  cursor: String!
}

enum ConversationOrderByInput {
  id_ASC
  id_DESC
  deleted_ASC
  deleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConversationPreviousValues {
  id: ID!
  deleted: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ConversationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  deleted: String
  deleted_not: String
  deleted_in: [String!]
  deleted_not_in: [String!]
  deleted_lt: String
  deleted_lte: String
  deleted_gt: String
  deleted_gte: String
  deleted_contains: String
  deleted_not_contains: String
  deleted_starts_with: String
  deleted_not_starts_with: String
  deleted_ends_with: String
  deleted_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
  NOT: [ConversationScalarWhereInput!]
}

type ConversationSubscriptionPayload {
  mutation: MutationType!
  node: Conversation
  updatedFields: [String!]
  previousValues: ConversationPreviousValues
}

input ConversationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConversationWhereInput
  AND: [ConversationSubscriptionWhereInput!]
}

input ConversationUpdateInput {
  speakers: UserUpdateManyWithoutConversationsInput
  messages: MessageUpdateManyWithoutConversationInput
  deleted: String
}

input ConversationUpdateManyDataInput {
  deleted: String
}

input ConversationUpdateManyMutationInput {
  deleted: String
}

input ConversationUpdateManyWithoutSpeakersInput {
  create: [ConversationCreateWithoutSpeakersInput!]
  delete: [ConversationWhereUniqueInput!]
  connect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  disconnect: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutSpeakersInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutSpeakersInput!]
  deleteMany: [ConversationScalarWhereInput!]
  updateMany: [ConversationUpdateManyWithWhereNestedInput!]
}

input ConversationUpdateManyWithWhereNestedInput {
  where: ConversationScalarWhereInput!
  data: ConversationUpdateManyDataInput!
}

input ConversationUpdateOneRequiredWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput
  update: ConversationUpdateWithoutMessagesDataInput
  upsert: ConversationUpsertWithoutMessagesInput
  connect: ConversationWhereUniqueInput
}

input ConversationUpdateWithoutMessagesDataInput {
  speakers: UserUpdateManyWithoutConversationsInput
  deleted: String
}

input ConversationUpdateWithoutSpeakersDataInput {
  messages: MessageUpdateManyWithoutConversationInput
  deleted: String
}

input ConversationUpdateWithWhereUniqueWithoutSpeakersInput {
  where: ConversationWhereUniqueInput!
  data: ConversationUpdateWithoutSpeakersDataInput!
}

input ConversationUpsertWithoutMessagesInput {
  update: ConversationUpdateWithoutMessagesDataInput!
  create: ConversationCreateWithoutMessagesInput!
}

input ConversationUpsertWithWhereUniqueWithoutSpeakersInput {
  where: ConversationWhereUniqueInput!
  update: ConversationUpdateWithoutSpeakersDataInput!
  create: ConversationCreateWithoutSpeakersInput!
}

input ConversationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  speakers_some: UserWhereInput
  messages_some: MessageWhereInput
  deleted: String
  deleted_not: String
  deleted_in: [String!]
  deleted_not_in: [String!]
  deleted_lt: String
  deleted_lte: String
  deleted_gt: String
  deleted_gte: String
  deleted_contains: String
  deleted_not_contains: String
  deleted_starts_with: String
  deleted_not_starts_with: String
  deleted_ends_with: String
  deleted_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConversationWhereInput!]
}

input ConversationWhereUniqueInput {
  id: ID
}

scalar DateTime

type Debate {
  id: ID!
  owner: User
  ownerBlue: User
  ownerRed: User
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  topComment: Comment
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
  positives(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  negatives(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  redVotes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  blueVotes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  winner: User
  loser: User
  closed: Boolean!
  crowned: Boolean!
  published: Boolean!
  interactions(where: InteractionWhereInput, orderBy: InteractionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interaction!]
  answerOne: String
  answerTwo: String
  image: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DebateConnection {
  pageInfo: PageInfo!
  edges: [DebateEdge]!
  aggregate: AggregateDebate!
}

input DebateCreateInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateManyWithoutOwnerBlueInput {
  create: [DebateCreateWithoutOwnerBlueInput!]
  connect: [DebateWhereUniqueInput!]
}

input DebateCreateManyWithoutOwnerInput {
  create: [DebateCreateWithoutOwnerInput!]
  connect: [DebateWhereUniqueInput!]
}

input DebateCreateManyWithoutOwnerRedInput {
  create: [DebateCreateWithoutOwnerRedInput!]
  connect: [DebateWhereUniqueInput!]
}

input DebateCreateOneInput {
  create: DebateCreateInput
  connect: DebateWhereUniqueInput
}

input DebateCreateOneWithoutCommentsInput {
  create: DebateCreateWithoutCommentsInput
  connect: DebateWhereUniqueInput
}

input DebateCreateOneWithoutInteractionsInput {
  create: DebateCreateWithoutInteractionsInput
  connect: DebateWhereUniqueInput
}

input DebateCreateOneWithoutReportsInput {
  create: DebateCreateWithoutReportsInput
  connect: DebateWhereUniqueInput
}

input DebateCreateWithoutCommentsInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateWithoutInteractionsInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateWithoutOwnerBlueInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateWithoutOwnerInput {
  id: ID
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateWithoutOwnerRedInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  reports: ReportCreateManyWithoutDebateInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateCreateWithoutReportsInput {
  id: ID
  owner: UserCreateOneWithoutDebatesInput
  ownerBlue: UserCreateOneWithoutDebatesBlueInput
  ownerRed: UserCreateOneWithoutDebatesRedInput
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  comments: CommentCreateManyWithoutDebateInput
  topComment: CommentCreateOneInput
  positives: UserCreateManyInput
  negatives: UserCreateManyInput
  redVotes: UserCreateManyInput
  blueVotes: UserCreateManyInput
  winner: UserCreateOneInput
  loser: UserCreateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionCreateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

type DebateEdge {
  node: Debate!
  cursor: String!
}

enum DebateOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  timelimit_ASC
  timelimit_DESC
  timelimitString_ASC
  timelimitString_DESC
  type_ASC
  type_DESC
  closed_ASC
  closed_DESC
  crowned_ASC
  crowned_DESC
  published_ASC
  published_DESC
  answerOne_ASC
  answerOne_DESC
  answerTwo_ASC
  answerTwo_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DebatePreviousValues {
  id: ID!
  content: String!
  timelimit: DateTime
  timelimitString: String
  type: DebateType!
  closed: Boolean!
  crowned: Boolean!
  published: Boolean!
  answerOne: String
  answerTwo: String
  image: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input DebateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  timelimit: DateTime
  timelimit_not: DateTime
  timelimit_in: [DateTime!]
  timelimit_not_in: [DateTime!]
  timelimit_lt: DateTime
  timelimit_lte: DateTime
  timelimit_gt: DateTime
  timelimit_gte: DateTime
  timelimitString: String
  timelimitString_not: String
  timelimitString_in: [String!]
  timelimitString_not_in: [String!]
  timelimitString_lt: String
  timelimitString_lte: String
  timelimitString_gt: String
  timelimitString_gte: String
  timelimitString_contains: String
  timelimitString_not_contains: String
  timelimitString_starts_with: String
  timelimitString_not_starts_with: String
  timelimitString_ends_with: String
  timelimitString_not_ends_with: String
  type: DebateType
  type_not: DebateType
  type_in: [DebateType!]
  type_not_in: [DebateType!]
  closed: Boolean
  closed_not: Boolean
  crowned: Boolean
  crowned_not: Boolean
  published: Boolean
  published_not: Boolean
  answerOne: String
  answerOne_not: String
  answerOne_in: [String!]
  answerOne_not_in: [String!]
  answerOne_lt: String
  answerOne_lte: String
  answerOne_gt: String
  answerOne_gte: String
  answerOne_contains: String
  answerOne_not_contains: String
  answerOne_starts_with: String
  answerOne_not_starts_with: String
  answerOne_ends_with: String
  answerOne_not_ends_with: String
  answerTwo: String
  answerTwo_not: String
  answerTwo_in: [String!]
  answerTwo_not_in: [String!]
  answerTwo_lt: String
  answerTwo_lte: String
  answerTwo_gt: String
  answerTwo_gte: String
  answerTwo_contains: String
  answerTwo_not_contains: String
  answerTwo_starts_with: String
  answerTwo_not_starts_with: String
  answerTwo_ends_with: String
  answerTwo_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DebateScalarWhereInput!]
  OR: [DebateScalarWhereInput!]
  NOT: [DebateScalarWhereInput!]
}

type DebateSubscriptionPayload {
  mutation: MutationType!
  node: Debate
  updatedFields: [String!]
  previousValues: DebatePreviousValues
}

input DebateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DebateWhereInput
  AND: [DebateSubscriptionWhereInput!]
}

enum DebateType {
  STANDARD
  DUO
  MUDDLE
}

input DebateUpdateDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateManyDataInput {
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  closed: Boolean
  crowned: Boolean
  published: Boolean
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateManyMutationInput {
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  closed: Boolean
  crowned: Boolean
  published: Boolean
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateManyWithoutOwnerBlueInput {
  create: [DebateCreateWithoutOwnerBlueInput!]
  delete: [DebateWhereUniqueInput!]
  connect: [DebateWhereUniqueInput!]
  set: [DebateWhereUniqueInput!]
  disconnect: [DebateWhereUniqueInput!]
  update: [DebateUpdateWithWhereUniqueWithoutOwnerBlueInput!]
  upsert: [DebateUpsertWithWhereUniqueWithoutOwnerBlueInput!]
  deleteMany: [DebateScalarWhereInput!]
  updateMany: [DebateUpdateManyWithWhereNestedInput!]
}

input DebateUpdateManyWithoutOwnerInput {
  create: [DebateCreateWithoutOwnerInput!]
  delete: [DebateWhereUniqueInput!]
  connect: [DebateWhereUniqueInput!]
  set: [DebateWhereUniqueInput!]
  disconnect: [DebateWhereUniqueInput!]
  update: [DebateUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [DebateUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [DebateScalarWhereInput!]
  updateMany: [DebateUpdateManyWithWhereNestedInput!]
}

input DebateUpdateManyWithoutOwnerRedInput {
  create: [DebateCreateWithoutOwnerRedInput!]
  delete: [DebateWhereUniqueInput!]
  connect: [DebateWhereUniqueInput!]
  set: [DebateWhereUniqueInput!]
  disconnect: [DebateWhereUniqueInput!]
  update: [DebateUpdateWithWhereUniqueWithoutOwnerRedInput!]
  upsert: [DebateUpsertWithWhereUniqueWithoutOwnerRedInput!]
  deleteMany: [DebateScalarWhereInput!]
  updateMany: [DebateUpdateManyWithWhereNestedInput!]
}

input DebateUpdateManyWithWhereNestedInput {
  where: DebateScalarWhereInput!
  data: DebateUpdateManyDataInput!
}

input DebateUpdateOneInput {
  create: DebateCreateInput
  update: DebateUpdateDataInput
  upsert: DebateUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DebateWhereUniqueInput
}

input DebateUpdateOneRequiredWithoutCommentsInput {
  create: DebateCreateWithoutCommentsInput
  update: DebateUpdateWithoutCommentsDataInput
  upsert: DebateUpsertWithoutCommentsInput
  connect: DebateWhereUniqueInput
}

input DebateUpdateOneWithoutInteractionsInput {
  create: DebateCreateWithoutInteractionsInput
  update: DebateUpdateWithoutInteractionsDataInput
  upsert: DebateUpsertWithoutInteractionsInput
  delete: Boolean
  disconnect: Boolean
  connect: DebateWhereUniqueInput
}

input DebateUpdateOneWithoutReportsInput {
  create: DebateCreateWithoutReportsInput
  update: DebateUpdateWithoutReportsDataInput
  upsert: DebateUpsertWithoutReportsInput
  delete: Boolean
  disconnect: Boolean
  connect: DebateWhereUniqueInput
}

input DebateUpdateWithoutCommentsDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithoutInteractionsDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithoutOwnerBlueDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithoutOwnerDataInput {
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithoutOwnerRedDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  reports: ReportUpdateManyWithoutDebateInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithoutReportsDataInput {
  owner: UserUpdateOneWithoutDebatesInput
  ownerBlue: UserUpdateOneWithoutDebatesBlueInput
  ownerRed: UserUpdateOneWithoutDebatesRedInput
  content: String
  timelimit: DateTime
  timelimitString: String
  type: DebateType
  comments: CommentUpdateManyWithoutDebateInput
  topComment: CommentUpdateOneInput
  positives: UserUpdateManyInput
  negatives: UserUpdateManyInput
  redVotes: UserUpdateManyInput
  blueVotes: UserUpdateManyInput
  winner: UserUpdateOneInput
  loser: UserUpdateOneInput
  closed: Boolean
  crowned: Boolean
  published: Boolean
  interactions: InteractionUpdateManyWithoutDebateInput
  answerOne: String
  answerTwo: String
  image: String
}

input DebateUpdateWithWhereUniqueWithoutOwnerBlueInput {
  where: DebateWhereUniqueInput!
  data: DebateUpdateWithoutOwnerBlueDataInput!
}

input DebateUpdateWithWhereUniqueWithoutOwnerInput {
  where: DebateWhereUniqueInput!
  data: DebateUpdateWithoutOwnerDataInput!
}

input DebateUpdateWithWhereUniqueWithoutOwnerRedInput {
  where: DebateWhereUniqueInput!
  data: DebateUpdateWithoutOwnerRedDataInput!
}

input DebateUpsertNestedInput {
  update: DebateUpdateDataInput!
  create: DebateCreateInput!
}

input DebateUpsertWithoutCommentsInput {
  update: DebateUpdateWithoutCommentsDataInput!
  create: DebateCreateWithoutCommentsInput!
}

input DebateUpsertWithoutInteractionsInput {
  update: DebateUpdateWithoutInteractionsDataInput!
  create: DebateCreateWithoutInteractionsInput!
}

input DebateUpsertWithoutReportsInput {
  update: DebateUpdateWithoutReportsDataInput!
  create: DebateCreateWithoutReportsInput!
}

input DebateUpsertWithWhereUniqueWithoutOwnerBlueInput {
  where: DebateWhereUniqueInput!
  update: DebateUpdateWithoutOwnerBlueDataInput!
  create: DebateCreateWithoutOwnerBlueInput!
}

input DebateUpsertWithWhereUniqueWithoutOwnerInput {
  where: DebateWhereUniqueInput!
  update: DebateUpdateWithoutOwnerDataInput!
  create: DebateCreateWithoutOwnerInput!
}

input DebateUpsertWithWhereUniqueWithoutOwnerRedInput {
  where: DebateWhereUniqueInput!
  update: DebateUpdateWithoutOwnerRedDataInput!
  create: DebateCreateWithoutOwnerRedInput!
}

input DebateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  ownerBlue: UserWhereInput
  ownerRed: UserWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  timelimit: DateTime
  timelimit_not: DateTime
  timelimit_in: [DateTime!]
  timelimit_not_in: [DateTime!]
  timelimit_lt: DateTime
  timelimit_lte: DateTime
  timelimit_gt: DateTime
  timelimit_gte: DateTime
  timelimitString: String
  timelimitString_not: String
  timelimitString_in: [String!]
  timelimitString_not_in: [String!]
  timelimitString_lt: String
  timelimitString_lte: String
  timelimitString_gt: String
  timelimitString_gte: String
  timelimitString_contains: String
  timelimitString_not_contains: String
  timelimitString_starts_with: String
  timelimitString_not_starts_with: String
  timelimitString_ends_with: String
  timelimitString_not_ends_with: String
  type: DebateType
  type_not: DebateType
  type_in: [DebateType!]
  type_not_in: [DebateType!]
  comments_some: CommentWhereInput
  topComment: CommentWhereInput
  reports_some: ReportWhereInput
  positives_some: UserWhereInput
  negatives_some: UserWhereInput
  redVotes_some: UserWhereInput
  blueVotes_some: UserWhereInput
  winner: UserWhereInput
  loser: UserWhereInput
  closed: Boolean
  closed_not: Boolean
  crowned: Boolean
  crowned_not: Boolean
  published: Boolean
  published_not: Boolean
  interactions_some: InteractionWhereInput
  answerOne: String
  answerOne_not: String
  answerOne_in: [String!]
  answerOne_not_in: [String!]
  answerOne_lt: String
  answerOne_lte: String
  answerOne_gt: String
  answerOne_gte: String
  answerOne_contains: String
  answerOne_not_contains: String
  answerOne_starts_with: String
  answerOne_not_starts_with: String
  answerOne_ends_with: String
  answerOne_not_ends_with: String
  answerTwo: String
  answerTwo_not: String
  answerTwo_in: [String!]
  answerTwo_not_in: [String!]
  answerTwo_lt: String
  answerTwo_lte: String
  answerTwo_gt: String
  answerTwo_gte: String
  answerTwo_contains: String
  answerTwo_not_contains: String
  answerTwo_starts_with: String
  answerTwo_not_starts_with: String
  answerTwo_ends_with: String
  answerTwo_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DebateWhereInput!]
}

input DebateWhereUniqueInput {
  id: ID
}

enum Gender {
  MALE
  FEMALE
  NO_INDICATION
}

enum GenderFilter {
  MALE
  FEMALE
  ALL
}

type Interaction {
  id: ID!
  type: InteractionType!
  who: User!
  debate: Debate
  comment: Comment
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InteractionConnection {
  pageInfo: PageInfo!
  edges: [InteractionEdge]!
  aggregate: AggregateInteraction!
}

input InteractionCreateInput {
  id: ID
  type: InteractionType!
  who: UserCreateOneWithoutInteractionsInput!
  debate: DebateCreateOneWithoutInteractionsInput
  comment: CommentCreateOneInput
}

input InteractionCreateManyWithoutDebateInput {
  create: [InteractionCreateWithoutDebateInput!]
  connect: [InteractionWhereUniqueInput!]
}

input InteractionCreateManyWithoutWhoInput {
  create: [InteractionCreateWithoutWhoInput!]
  connect: [InteractionWhereUniqueInput!]
}

input InteractionCreateWithoutDebateInput {
  id: ID
  type: InteractionType!
  who: UserCreateOneWithoutInteractionsInput!
  comment: CommentCreateOneInput
}

input InteractionCreateWithoutWhoInput {
  id: ID
  type: InteractionType!
  debate: DebateCreateOneWithoutInteractionsInput
  comment: CommentCreateOneInput
}

type InteractionEdge {
  node: Interaction!
  cursor: String!
}

enum InteractionOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InteractionPreviousValues {
  id: ID!
  type: InteractionType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InteractionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: InteractionType
  type_not: InteractionType
  type_in: [InteractionType!]
  type_not_in: [InteractionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InteractionScalarWhereInput!]
  OR: [InteractionScalarWhereInput!]
  NOT: [InteractionScalarWhereInput!]
}

type InteractionSubscriptionPayload {
  mutation: MutationType!
  node: Interaction
  updatedFields: [String!]
  previousValues: InteractionPreviousValues
}

input InteractionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InteractionWhereInput
  AND: [InteractionSubscriptionWhereInput!]
}

enum InteractionType {
  LIKE
  DISLIKE
  COMMENT
  POSITIVE_VOTE
  NEGATIVE_VOTE
  BLUE_VOTE
  RED_VOTE
}

input InteractionUpdateInput {
  type: InteractionType
  who: UserUpdateOneRequiredWithoutInteractionsInput
  debate: DebateUpdateOneWithoutInteractionsInput
  comment: CommentUpdateOneInput
}

input InteractionUpdateManyDataInput {
  type: InteractionType
}

input InteractionUpdateManyMutationInput {
  type: InteractionType
}

input InteractionUpdateManyWithoutDebateInput {
  create: [InteractionCreateWithoutDebateInput!]
  delete: [InteractionWhereUniqueInput!]
  connect: [InteractionWhereUniqueInput!]
  set: [InteractionWhereUniqueInput!]
  disconnect: [InteractionWhereUniqueInput!]
  update: [InteractionUpdateWithWhereUniqueWithoutDebateInput!]
  upsert: [InteractionUpsertWithWhereUniqueWithoutDebateInput!]
  deleteMany: [InteractionScalarWhereInput!]
  updateMany: [InteractionUpdateManyWithWhereNestedInput!]
}

input InteractionUpdateManyWithoutWhoInput {
  create: [InteractionCreateWithoutWhoInput!]
  delete: [InteractionWhereUniqueInput!]
  connect: [InteractionWhereUniqueInput!]
  set: [InteractionWhereUniqueInput!]
  disconnect: [InteractionWhereUniqueInput!]
  update: [InteractionUpdateWithWhereUniqueWithoutWhoInput!]
  upsert: [InteractionUpsertWithWhereUniqueWithoutWhoInput!]
  deleteMany: [InteractionScalarWhereInput!]
  updateMany: [InteractionUpdateManyWithWhereNestedInput!]
}

input InteractionUpdateManyWithWhereNestedInput {
  where: InteractionScalarWhereInput!
  data: InteractionUpdateManyDataInput!
}

input InteractionUpdateWithoutDebateDataInput {
  type: InteractionType
  who: UserUpdateOneRequiredWithoutInteractionsInput
  comment: CommentUpdateOneInput
}

input InteractionUpdateWithoutWhoDataInput {
  type: InteractionType
  debate: DebateUpdateOneWithoutInteractionsInput
  comment: CommentUpdateOneInput
}

input InteractionUpdateWithWhereUniqueWithoutDebateInput {
  where: InteractionWhereUniqueInput!
  data: InteractionUpdateWithoutDebateDataInput!
}

input InteractionUpdateWithWhereUniqueWithoutWhoInput {
  where: InteractionWhereUniqueInput!
  data: InteractionUpdateWithoutWhoDataInput!
}

input InteractionUpsertWithWhereUniqueWithoutDebateInput {
  where: InteractionWhereUniqueInput!
  update: InteractionUpdateWithoutDebateDataInput!
  create: InteractionCreateWithoutDebateInput!
}

input InteractionUpsertWithWhereUniqueWithoutWhoInput {
  where: InteractionWhereUniqueInput!
  update: InteractionUpdateWithoutWhoDataInput!
  create: InteractionCreateWithoutWhoInput!
}

input InteractionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: InteractionType
  type_not: InteractionType
  type_in: [InteractionType!]
  type_not_in: [InteractionType!]
  who: UserWhereInput
  debate: DebateWhereInput
  comment: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InteractionWhereInput!]
}

input InteractionWhereUniqueInput {
  id: ID
}

enum Language {
  FR
  EN
}

scalar Long

enum MailStatus {
  HEALTHY
  BLOCKED
}

type Message {
  id: ID!
  content: String!
  to: User!
  from: User!
  read: Boolean!
  conversation: Conversation!
  deleted: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  content: String!
  to: UserCreateOneInput!
  from: UserCreateOneInput!
  read: Boolean!
  conversation: ConversationCreateOneWithoutMessagesInput!
  deleted: String
}

input MessageCreateManyWithoutConversationInput {
  create: [MessageCreateWithoutConversationInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateWithoutConversationInput {
  id: ID
  content: String!
  to: UserCreateOneInput!
  from: UserCreateOneInput!
  read: Boolean!
  deleted: String
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  read_ASC
  read_DESC
  deleted_ASC
  deleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MessagePreviousValues {
  id: ID!
  content: String!
  read: Boolean!
  deleted: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  read: Boolean
  read_not: Boolean
  deleted: String
  deleted_not: String
  deleted_in: [String!]
  deleted_not_in: [String!]
  deleted_lt: String
  deleted_lte: String
  deleted_gt: String
  deleted_gte: String
  deleted_contains: String
  deleted_not_contains: String
  deleted_starts_with: String
  deleted_not_starts_with: String
  deleted_ends_with: String
  deleted_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
}

input MessageUpdateInput {
  content: String
  to: UserUpdateOneRequiredInput
  from: UserUpdateOneRequiredInput
  read: Boolean
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
  deleted: String
}

input MessageUpdateManyDataInput {
  content: String
  read: Boolean
  deleted: String
}

input MessageUpdateManyMutationInput {
  content: String
  read: Boolean
  deleted: String
}

input MessageUpdateManyWithoutConversationInput {
  create: [MessageCreateWithoutConversationInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutConversationInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutConversationInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateWithoutConversationDataInput {
  content: String
  to: UserUpdateOneRequiredInput
  from: UserUpdateOneRequiredInput
  read: Boolean
  deleted: String
}

input MessageUpdateWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutConversationDataInput!
}

input MessageUpsertWithWhereUniqueWithoutConversationInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutConversationDataInput!
  create: MessageCreateWithoutConversationInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  to: UserWhereInput
  from: UserWhereInput
  read: Boolean
  read_not: Boolean
  conversation: ConversationWhereInput
  deleted: String
  deleted_not: String
  deleted_in: [String!]
  deleted_not_in: [String!]
  deleted_lt: String
  deleted_lte: String
  deleted_gt: String
  deleted_gte: String
  deleted_contains: String
  deleted_not_contains: String
  deleted_starts_with: String
  deleted_not_starts_with: String
  deleted_ends_with: String
  deleted_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createAd(data: AdCreateInput!): Ad!
  updateAd(data: AdUpdateInput!, where: AdWhereUniqueInput!): Ad
  updateManyAds(data: AdUpdateManyMutationInput!, where: AdWhereInput): BatchPayload!
  upsertAd(where: AdWhereUniqueInput!, create: AdCreateInput!, update: AdUpdateInput!): Ad!
  deleteAd(where: AdWhereUniqueInput!): Ad
  deleteManyAds(where: AdWhereInput): BatchPayload!
  createAdTarget(data: AdTargetCreateInput!): AdTarget!
  updateAdTarget(data: AdTargetUpdateInput!, where: AdTargetWhereUniqueInput!): AdTarget
  updateManyAdTargets(data: AdTargetUpdateManyMutationInput!, where: AdTargetWhereInput): BatchPayload!
  upsertAdTarget(where: AdTargetWhereUniqueInput!, create: AdTargetCreateInput!, update: AdTargetUpdateInput!): AdTarget!
  deleteAdTarget(where: AdTargetWhereUniqueInput!): AdTarget
  deleteManyAdTargets(where: AdTargetWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createConnected(data: ConnectedCreateInput!): Connected!
  updateConnected(data: ConnectedUpdateInput!, where: ConnectedWhereUniqueInput!): Connected
  updateManyConnecteds(data: ConnectedUpdateManyMutationInput!, where: ConnectedWhereInput): BatchPayload!
  upsertConnected(where: ConnectedWhereUniqueInput!, create: ConnectedCreateInput!, update: ConnectedUpdateInput!): Connected!
  deleteConnected(where: ConnectedWhereUniqueInput!): Connected
  deleteManyConnecteds(where: ConnectedWhereInput): BatchPayload!
  createConversation(data: ConversationCreateInput!): Conversation!
  updateConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  updateManyConversations(data: ConversationUpdateManyMutationInput!, where: ConversationWhereInput): BatchPayload!
  upsertConversation(where: ConversationWhereUniqueInput!, create: ConversationCreateInput!, update: ConversationUpdateInput!): Conversation!
  deleteConversation(where: ConversationWhereUniqueInput!): Conversation
  deleteManyConversations(where: ConversationWhereInput): BatchPayload!
  createDebate(data: DebateCreateInput!): Debate!
  updateDebate(data: DebateUpdateInput!, where: DebateWhereUniqueInput!): Debate
  updateManyDebates(data: DebateUpdateManyMutationInput!, where: DebateWhereInput): BatchPayload!
  upsertDebate(where: DebateWhereUniqueInput!, create: DebateCreateInput!, update: DebateUpdateInput!): Debate!
  deleteDebate(where: DebateWhereUniqueInput!): Debate
  deleteManyDebates(where: DebateWhereInput): BatchPayload!
  createInteraction(data: InteractionCreateInput!): Interaction!
  updateInteraction(data: InteractionUpdateInput!, where: InteractionWhereUniqueInput!): Interaction
  updateManyInteractions(data: InteractionUpdateManyMutationInput!, where: InteractionWhereInput): BatchPayload!
  upsertInteraction(where: InteractionWhereUniqueInput!, create: InteractionCreateInput!, update: InteractionUpdateInput!): Interaction!
  deleteInteraction(where: InteractionWhereUniqueInput!): Interaction
  deleteManyInteractions(where: InteractionWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createNotification(data: NotificationCreateInput!): Notification!
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateManyNotifications(data: NotificationUpdateManyMutationInput!, where: NotificationWhereInput): BatchPayload!
  upsertNotification(where: NotificationWhereUniqueInput!, create: NotificationCreateInput!, update: NotificationUpdateInput!): Notification!
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteManyNotifications(where: NotificationWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createStatistique(data: StatistiqueCreateInput!): Statistique!
  updateStatistique(data: StatistiqueUpdateInput!, where: StatistiqueWhereUniqueInput!): Statistique
  updateManyStatistiques(data: StatistiqueUpdateManyMutationInput!, where: StatistiqueWhereInput): BatchPayload!
  upsertStatistique(where: StatistiqueWhereUniqueInput!, create: StatistiqueCreateInput!, update: StatistiqueUpdateInput!): Statistique!
  deleteStatistique(where: StatistiqueWhereUniqueInput!): Statistique
  deleteManyStatistiques(where: StatistiqueWhereInput): BatchPayload!
  createTmpUser(data: TmpUserCreateInput!): TmpUser!
  updateTmpUser(data: TmpUserUpdateInput!, where: TmpUserWhereUniqueInput!): TmpUser
  updateManyTmpUsers(data: TmpUserUpdateManyMutationInput!, where: TmpUserWhereInput): BatchPayload!
  upsertTmpUser(where: TmpUserWhereUniqueInput!, create: TmpUserCreateInput!, update: TmpUserUpdateInput!): TmpUser!
  deleteTmpUser(where: TmpUserWhereUniqueInput!): TmpUser
  deleteManyTmpUsers(where: TmpUserWhereInput): BatchPayload!
  createTrophy(data: TrophyCreateInput!): Trophy!
  updateTrophy(data: TrophyUpdateInput!, where: TrophyWhereUniqueInput!): Trophy
  updateManyTrophies(data: TrophyUpdateManyMutationInput!, where: TrophyWhereInput): BatchPayload!
  upsertTrophy(where: TrophyWhereUniqueInput!, create: TrophyCreateInput!, update: TrophyUpdateInput!): Trophy!
  deleteTrophy(where: TrophyWhereUniqueInput!): Trophy
  deleteManyTrophies(where: TrophyWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Notification {
  id: ID!
  who(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  userId: String!
  type: NotificationType!
  status: NotificationStatus!
  new: Boolean!
  debate: Debate
  comment: Comment
  createdAt: DateTime!
  updatedAt: DateTime!
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]!
  aggregate: AggregateNotification!
}

input NotificationCreateInput {
  id: ID
  who: UserCreateManyWithoutNotificationsInput
  userId: String!
  type: NotificationType!
  status: NotificationStatus!
  new: Boolean!
  debate: DebateCreateOneInput
  comment: CommentCreateOneInput
}

input NotificationCreateManyWithoutWhoInput {
  create: [NotificationCreateWithoutWhoInput!]
  connect: [NotificationWhereUniqueInput!]
}

input NotificationCreateWithoutWhoInput {
  id: ID
  userId: String!
  type: NotificationType!
  status: NotificationStatus!
  new: Boolean!
  debate: DebateCreateOneInput
  comment: CommentCreateOneInput
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

enum NotificationOrderByInput {
  id_ASC
  id_DESC
  userId_ASC
  userId_DESC
  type_ASC
  type_DESC
  status_ASC
  status_DESC
  new_ASC
  new_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NotificationPreviousValues {
  id: ID!
  userId: String!
  type: NotificationType!
  status: NotificationStatus!
  new: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input NotificationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: String
  userId_not: String
  userId_in: [String!]
  userId_not_in: [String!]
  userId_lt: String
  userId_lte: String
  userId_gt: String
  userId_gte: String
  userId_contains: String
  userId_not_contains: String
  userId_starts_with: String
  userId_not_starts_with: String
  userId_ends_with: String
  userId_not_ends_with: String
  type: NotificationType
  type_not: NotificationType
  type_in: [NotificationType!]
  type_not_in: [NotificationType!]
  status: NotificationStatus
  status_not: NotificationStatus
  status_in: [NotificationStatus!]
  status_not_in: [NotificationStatus!]
  new: Boolean
  new_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NotificationScalarWhereInput!]
  OR: [NotificationScalarWhereInput!]
  NOT: [NotificationScalarWhereInput!]
}

enum NotificationStatus {
  ACCEPTED
  DECLINED
  PENDING
  INFORMATION
}

type NotificationSubscriptionPayload {
  mutation: MutationType!
  node: Notification
  updatedFields: [String!]
  previousValues: NotificationPreviousValues
}

input NotificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationWhereInput
  AND: [NotificationSubscriptionWhereInput!]
}

enum NotificationType {
  VOTE
  INVITATION_DUO
  ACCEPT_DUO
  REJECT_DUO
  CLOSE_DEBATE
  ACCEPT_CLOSE_DEBATE
  REJECT_CLOSE_DEBATE
  DELETE_DEBATE
  ACCEPT_DELETE_DEBATE
  REJECT_DELETE_DEBATE
  COMMENT
  SUBCOMMENT
  LIKE
  DISLIKE
  CROWNED
  FOLLOW
  TOP_COMMENT
  WON_DEBATE
}

input NotificationUpdateInput {
  who: UserUpdateManyWithoutNotificationsInput
  userId: String
  type: NotificationType
  status: NotificationStatus
  new: Boolean
  debate: DebateUpdateOneInput
  comment: CommentUpdateOneInput
}

input NotificationUpdateManyDataInput {
  userId: String
  type: NotificationType
  status: NotificationStatus
  new: Boolean
}

input NotificationUpdateManyMutationInput {
  userId: String
  type: NotificationType
  status: NotificationStatus
  new: Boolean
}

input NotificationUpdateManyWithoutWhoInput {
  create: [NotificationCreateWithoutWhoInput!]
  delete: [NotificationWhereUniqueInput!]
  connect: [NotificationWhereUniqueInput!]
  set: [NotificationWhereUniqueInput!]
  disconnect: [NotificationWhereUniqueInput!]
  update: [NotificationUpdateWithWhereUniqueWithoutWhoInput!]
  upsert: [NotificationUpsertWithWhereUniqueWithoutWhoInput!]
  deleteMany: [NotificationScalarWhereInput!]
  updateMany: [NotificationUpdateManyWithWhereNestedInput!]
}

input NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput!
  data: NotificationUpdateManyDataInput!
}

input NotificationUpdateWithoutWhoDataInput {
  userId: String
  type: NotificationType
  status: NotificationStatus
  new: Boolean
  debate: DebateUpdateOneInput
  comment: CommentUpdateOneInput
}

input NotificationUpdateWithWhereUniqueWithoutWhoInput {
  where: NotificationWhereUniqueInput!
  data: NotificationUpdateWithoutWhoDataInput!
}

input NotificationUpsertWithWhereUniqueWithoutWhoInput {
  where: NotificationWhereUniqueInput!
  update: NotificationUpdateWithoutWhoDataInput!
  create: NotificationCreateWithoutWhoInput!
}

input NotificationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  who_some: UserWhereInput
  userId: String
  userId_not: String
  userId_in: [String!]
  userId_not_in: [String!]
  userId_lt: String
  userId_lte: String
  userId_gt: String
  userId_gte: String
  userId_contains: String
  userId_not_contains: String
  userId_starts_with: String
  userId_not_starts_with: String
  userId_ends_with: String
  userId_not_ends_with: String
  type: NotificationType
  type_not: NotificationType
  type_in: [NotificationType!]
  type_not_in: [NotificationType!]
  status: NotificationStatus
  status_not: NotificationStatus
  status_in: [NotificationStatus!]
  status_not_in: [NotificationStatus!]
  new: Boolean
  new_not: Boolean
  debate: DebateWhereInput
  comment: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NotificationWhereInput!]
}

input NotificationWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  ad(where: AdWhereUniqueInput!): Ad
  ads(where: AdWhereInput, orderBy: AdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ad]!
  adsConnection(where: AdWhereInput, orderBy: AdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdConnection!
  adTarget(where: AdTargetWhereUniqueInput!): AdTarget
  adTargets(where: AdTargetWhereInput, orderBy: AdTargetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AdTarget]!
  adTargetsConnection(where: AdTargetWhereInput, orderBy: AdTargetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdTargetConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  connected(where: ConnectedWhereUniqueInput!): Connected
  connecteds(where: ConnectedWhereInput, orderBy: ConnectedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connected]!
  connectedsConnection(where: ConnectedWhereInput, orderBy: ConnectedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConnectedConnection!
  conversation(where: ConversationWhereUniqueInput!): Conversation
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation]!
  conversationsConnection(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConversationConnection!
  debate(where: DebateWhereUniqueInput!): Debate
  debates(where: DebateWhereInput, orderBy: DebateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debate]!
  debatesConnection(where: DebateWhereInput, orderBy: DebateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DebateConnection!
  interaction(where: InteractionWhereUniqueInput!): Interaction
  interactions(where: InteractionWhereInput, orderBy: InteractionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interaction]!
  interactionsConnection(where: InteractionWhereInput, orderBy: InteractionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InteractionConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification]!
  notificationsConnection(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  statistique(where: StatistiqueWhereUniqueInput!): Statistique
  statistiques(where: StatistiqueWhereInput, orderBy: StatistiqueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Statistique]!
  statistiquesConnection(where: StatistiqueWhereInput, orderBy: StatistiqueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatistiqueConnection!
  tmpUser(where: TmpUserWhereUniqueInput!): TmpUser
  tmpUsers(where: TmpUserWhereInput, orderBy: TmpUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TmpUser]!
  tmpUsersConnection(where: TmpUserWhereInput, orderBy: TmpUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TmpUserConnection!
  trophy(where: TrophyWhereUniqueInput!): Trophy
  trophies(where: TrophyWhereInput, orderBy: TrophyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trophy]!
  trophiesConnection(where: TrophyWhereInput, orderBy: TrophyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TrophyConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Report {
  id: ID!
  from: User
  to: User
  type: ReportType!
  reason: ReportReason!
  reasonText: String
  debate: Debate
  comment: Comment
  treated: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  from: UserCreateOneInput
  to: UserCreateOneInput
  type: ReportType!
  reason: ReportReason!
  reasonText: String
  debate: DebateCreateOneWithoutReportsInput
  comment: CommentCreateOneWithoutReportsInput
  treated: Boolean
}

input ReportCreateManyWithoutCommentInput {
  create: [ReportCreateWithoutCommentInput!]
  connect: [ReportWhereUniqueInput!]
}

input ReportCreateManyWithoutDebateInput {
  create: [ReportCreateWithoutDebateInput!]
  connect: [ReportWhereUniqueInput!]
}

input ReportCreateWithoutCommentInput {
  id: ID
  from: UserCreateOneInput
  to: UserCreateOneInput
  type: ReportType!
  reason: ReportReason!
  reasonText: String
  debate: DebateCreateOneWithoutReportsInput
  treated: Boolean
}

input ReportCreateWithoutDebateInput {
  id: ID
  from: UserCreateOneInput
  to: UserCreateOneInput
  type: ReportType!
  reason: ReportReason!
  reasonText: String
  comment: CommentCreateOneWithoutReportsInput
  treated: Boolean
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  reason_ASC
  reason_DESC
  reasonText_ASC
  reasonText_DESC
  treated_ASC
  treated_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReportPreviousValues {
  id: ID!
  type: ReportType!
  reason: ReportReason!
  reasonText: String
  treated: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ReportReason {
  INSULT
  RACISM
  SEXISM
  VIOLENCE
  PORNOGRAPHY
}

input ReportScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ReportType
  type_not: ReportType
  type_in: [ReportType!]
  type_not_in: [ReportType!]
  reason: ReportReason
  reason_not: ReportReason
  reason_in: [ReportReason!]
  reason_not_in: [ReportReason!]
  reasonText: String
  reasonText_not: String
  reasonText_in: [String!]
  reasonText_not_in: [String!]
  reasonText_lt: String
  reasonText_lte: String
  reasonText_gt: String
  reasonText_gte: String
  reasonText_contains: String
  reasonText_not_contains: String
  reasonText_starts_with: String
  reasonText_not_starts_with: String
  reasonText_ends_with: String
  reasonText_not_ends_with: String
  treated: Boolean
  treated_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReportScalarWhereInput!]
  OR: [ReportScalarWhereInput!]
  NOT: [ReportScalarWhereInput!]
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
}

enum ReportType {
  DEBATE
  COMMENT
}

input ReportUpdateInput {
  from: UserUpdateOneInput
  to: UserUpdateOneInput
  type: ReportType
  reason: ReportReason
  reasonText: String
  debate: DebateUpdateOneWithoutReportsInput
  comment: CommentUpdateOneWithoutReportsInput
  treated: Boolean
}

input ReportUpdateManyDataInput {
  type: ReportType
  reason: ReportReason
  reasonText: String
  treated: Boolean
}

input ReportUpdateManyMutationInput {
  type: ReportType
  reason: ReportReason
  reasonText: String
  treated: Boolean
}

input ReportUpdateManyWithoutCommentInput {
  create: [ReportCreateWithoutCommentInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  set: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  update: [ReportUpdateWithWhereUniqueWithoutCommentInput!]
  upsert: [ReportUpsertWithWhereUniqueWithoutCommentInput!]
  deleteMany: [ReportScalarWhereInput!]
  updateMany: [ReportUpdateManyWithWhereNestedInput!]
}

input ReportUpdateManyWithoutDebateInput {
  create: [ReportCreateWithoutDebateInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  set: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  update: [ReportUpdateWithWhereUniqueWithoutDebateInput!]
  upsert: [ReportUpsertWithWhereUniqueWithoutDebateInput!]
  deleteMany: [ReportScalarWhereInput!]
  updateMany: [ReportUpdateManyWithWhereNestedInput!]
}

input ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput!
  data: ReportUpdateManyDataInput!
}

input ReportUpdateWithoutCommentDataInput {
  from: UserUpdateOneInput
  to: UserUpdateOneInput
  type: ReportType
  reason: ReportReason
  reasonText: String
  debate: DebateUpdateOneWithoutReportsInput
  treated: Boolean
}

input ReportUpdateWithoutDebateDataInput {
  from: UserUpdateOneInput
  to: UserUpdateOneInput
  type: ReportType
  reason: ReportReason
  reasonText: String
  comment: CommentUpdateOneWithoutReportsInput
  treated: Boolean
}

input ReportUpdateWithWhereUniqueWithoutCommentInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateWithoutCommentDataInput!
}

input ReportUpdateWithWhereUniqueWithoutDebateInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateWithoutDebateDataInput!
}

input ReportUpsertWithWhereUniqueWithoutCommentInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateWithoutCommentDataInput!
  create: ReportCreateWithoutCommentInput!
}

input ReportUpsertWithWhereUniqueWithoutDebateInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateWithoutDebateDataInput!
  create: ReportCreateWithoutDebateInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: UserWhereInput
  to: UserWhereInput
  type: ReportType
  type_not: ReportType
  type_in: [ReportType!]
  type_not_in: [ReportType!]
  reason: ReportReason
  reason_not: ReportReason
  reason_in: [ReportReason!]
  reason_not_in: [ReportReason!]
  reasonText: String
  reasonText_not: String
  reasonText_in: [String!]
  reasonText_not_in: [String!]
  reasonText_lt: String
  reasonText_lte: String
  reasonText_gt: String
  reasonText_gte: String
  reasonText_contains: String
  reasonText_not_contains: String
  reasonText_starts_with: String
  reasonText_not_starts_with: String
  reasonText_ends_with: String
  reasonText_not_ends_with: String
  debate: DebateWhereInput
  comment: CommentWhereInput
  treated: Boolean
  treated_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

enum Role {
  STANDARD
  MODERATOR
  ADMIN
  MUDDLE
}

type Statistique {
  id: ID!
  connected(where: ConnectedWhereInput, orderBy: ConnectedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Connected!]
  crowns: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatistiqueConnection {
  pageInfo: PageInfo!
  edges: [StatistiqueEdge]!
  aggregate: AggregateStatistique!
}

input StatistiqueCreateInput {
  id: ID
  connected: ConnectedCreateManyInput
  crowns: Int
}

type StatistiqueEdge {
  node: Statistique!
  cursor: String!
}

enum StatistiqueOrderByInput {
  id_ASC
  id_DESC
  crowns_ASC
  crowns_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StatistiquePreviousValues {
  id: ID!
  crowns: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatistiqueSubscriptionPayload {
  mutation: MutationType!
  node: Statistique
  updatedFields: [String!]
  previousValues: StatistiquePreviousValues
}

input StatistiqueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatistiqueWhereInput
  AND: [StatistiqueSubscriptionWhereInput!]
}

input StatistiqueUpdateInput {
  connected: ConnectedUpdateManyInput
  crowns: Int
}

input StatistiqueUpdateManyMutationInput {
  crowns: Int
}

input StatistiqueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  connected_some: ConnectedWhereInput
  crowns: Int
  crowns_not: Int
  crowns_in: [Int!]
  crowns_not_in: [Int!]
  crowns_lt: Int
  crowns_lte: Int
  crowns_gt: Int
  crowns_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StatistiqueWhereInput!]
}

input StatistiqueWhereUniqueInput {
  id: ID
}

type Subscription {
  ad(where: AdSubscriptionWhereInput): AdSubscriptionPayload
  adTarget(where: AdTargetSubscriptionWhereInput): AdTargetSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  connected(where: ConnectedSubscriptionWhereInput): ConnectedSubscriptionPayload
  conversation(where: ConversationSubscriptionWhereInput): ConversationSubscriptionPayload
  debate(where: DebateSubscriptionWhereInput): DebateSubscriptionPayload
  interaction(where: InteractionSubscriptionWhereInput): InteractionSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  notification(where: NotificationSubscriptionWhereInput): NotificationSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  statistique(where: StatistiqueSubscriptionWhereInput): StatistiqueSubscriptionPayload
  tmpUser(where: TmpUserSubscriptionWhereInput): TmpUserSubscriptionPayload
  trophy(where: TrophySubscriptionWhereInput): TrophySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

enum Theme {
  LIGHT
  DARK
}

type TmpUser {
  id: ID!
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role!
  gender: Gender!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TmpUserConnection {
  pageInfo: PageInfo!
  edges: [TmpUserEdge]!
  aggregate: AggregateTmpUser!
}

input TmpUserCreateInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  gender: Gender
}

type TmpUserEdge {
  node: TmpUser!
  cursor: String!
}

enum TmpUserOrderByInput {
  id_ASC
  id_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  birthdate_ASC
  birthdate_DESC
  role_ASC
  role_DESC
  gender_ASC
  gender_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TmpUserPreviousValues {
  id: ID!
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role!
  gender: Gender!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TmpUserSubscriptionPayload {
  mutation: MutationType!
  node: TmpUser
  updatedFields: [String!]
  previousValues: TmpUserPreviousValues
}

input TmpUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TmpUserWhereInput
  AND: [TmpUserSubscriptionWhereInput!]
}

input TmpUserUpdateInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  gender: Gender
}

input TmpUserUpdateManyMutationInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  gender: Gender
}

input TmpUserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TmpUserWhereInput!]
}

input TmpUserWhereUniqueInput {
  id: ID
  email: String
}

type Trophy {
  id: ID!
  user: User!
  won: Boolean!
  type: TrophyType
  debate: Debate
  comment: Comment
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TrophyConnection {
  pageInfo: PageInfo!
  edges: [TrophyEdge]!
  aggregate: AggregateTrophy!
}

input TrophyCreateInput {
  id: ID
  user: UserCreateOneWithoutTrophiesInput!
  won: Boolean!
  type: TrophyType
  debate: DebateCreateOneInput
  comment: CommentCreateOneInput
}

input TrophyCreateManyWithoutUserInput {
  create: [TrophyCreateWithoutUserInput!]
  connect: [TrophyWhereUniqueInput!]
}

input TrophyCreateWithoutUserInput {
  id: ID
  won: Boolean!
  type: TrophyType
  debate: DebateCreateOneInput
  comment: CommentCreateOneInput
}

type TrophyEdge {
  node: Trophy!
  cursor: String!
}

enum TrophyOrderByInput {
  id_ASC
  id_DESC
  won_ASC
  won_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TrophyPreviousValues {
  id: ID!
  won: Boolean!
  type: TrophyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TrophyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  won: Boolean
  won_not: Boolean
  type: TrophyType
  type_not: TrophyType
  type_in: [TrophyType!]
  type_not_in: [TrophyType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TrophyScalarWhereInput!]
  OR: [TrophyScalarWhereInput!]
  NOT: [TrophyScalarWhereInput!]
}

type TrophySubscriptionPayload {
  mutation: MutationType!
  node: Trophy
  updatedFields: [String!]
  previousValues: TrophyPreviousValues
}

input TrophySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TrophyWhereInput
  AND: [TrophySubscriptionWhereInput!]
}

enum TrophyType {
  DUO
  TOP_COMMENT
}

input TrophyUpdateInput {
  user: UserUpdateOneRequiredWithoutTrophiesInput
  won: Boolean
  type: TrophyType
  debate: DebateUpdateOneInput
  comment: CommentUpdateOneInput
}

input TrophyUpdateManyDataInput {
  won: Boolean
  type: TrophyType
}

input TrophyUpdateManyMutationInput {
  won: Boolean
  type: TrophyType
}

input TrophyUpdateManyWithoutUserInput {
  create: [TrophyCreateWithoutUserInput!]
  delete: [TrophyWhereUniqueInput!]
  connect: [TrophyWhereUniqueInput!]
  set: [TrophyWhereUniqueInput!]
  disconnect: [TrophyWhereUniqueInput!]
  update: [TrophyUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TrophyUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TrophyScalarWhereInput!]
  updateMany: [TrophyUpdateManyWithWhereNestedInput!]
}

input TrophyUpdateManyWithWhereNestedInput {
  where: TrophyScalarWhereInput!
  data: TrophyUpdateManyDataInput!
}

input TrophyUpdateWithoutUserDataInput {
  won: Boolean
  type: TrophyType
  debate: DebateUpdateOneInput
  comment: CommentUpdateOneInput
}

input TrophyUpdateWithWhereUniqueWithoutUserInput {
  where: TrophyWhereUniqueInput!
  data: TrophyUpdateWithoutUserDataInput!
}

input TrophyUpsertWithWhereUniqueWithoutUserInput {
  where: TrophyWhereUniqueInput!
  update: TrophyUpdateWithoutUserDataInput!
  create: TrophyCreateWithoutUserInput!
}

input TrophyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  won: Boolean
  won_not: Boolean
  type: TrophyType
  type_not: TrophyType
  type_in: [TrophyType!]
  type_not_in: [TrophyType!]
  debate: DebateWhereInput
  comment: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TrophyWhereInput!]
}

input TrophyWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role!
  certified: Boolean!
  gender: Gender!
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language!
  theme: Theme!
  crowned: Boolean!
  crownedDate: DateTime
  private: Boolean!
  lastConnected: DateTime
  followers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  following(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  blocked(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  blocking(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  debates(where: DebateWhereInput, orderBy: DebateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debate!]
  debatesBlue(where: DebateWhereInput, orderBy: DebateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debate!]
  debatesRed(where: DebateWhereInput, orderBy: DebateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debate!]
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification!]
  trophies(where: TrophyWhereInput, orderBy: TrophyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trophy!]
  conversations(where: ConversationWhereInput, orderBy: ConversationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Conversation!]
  interactions(where: InteractionWhereInput, orderBy: InteractionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interaction!]
  mailStatus: MailStatus!
  mailErrors: [Int!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreatemailErrorsInput {
  set: [Int!]
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutBlockedInput {
  create: [UserCreateWithoutBlockedInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutBlockingInput {
  create: [UserCreateWithoutBlockingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutFollowersInput {
  create: [UserCreateWithoutFollowersInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutFollowingInput {
  create: [UserCreateWithoutFollowingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutNotificationsInput {
  create: [UserCreateWithoutNotificationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutDebatesBlueInput {
  create: UserCreateWithoutDebatesBlueInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutDebatesInput {
  create: UserCreateWithoutDebatesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutDebatesRedInput {
  create: UserCreateWithoutDebatesRedInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInteractionsInput {
  create: UserCreateWithoutInteractionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTrophiesInput {
  create: UserCreateWithoutTrophiesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBlockedInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutBlockingInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutConversationsInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutDebatesBlueInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutDebatesInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutDebatesRedInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutFollowersInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutFollowingInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutInteractionsInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutNotificationsInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  trophies: TrophyCreateManyWithoutUserInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

input UserCreateWithoutTrophiesInput {
  id: ID
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowersInput
  blocked: UserCreateManyWithoutBlockingInput
  blocking: UserCreateManyWithoutBlockedInput
  debates: DebateCreateManyWithoutOwnerInput
  debatesBlue: DebateCreateManyWithoutOwnerBlueInput
  debatesRed: DebateCreateManyWithoutOwnerRedInput
  notifications: NotificationCreateManyWithoutWhoInput
  conversations: ConversationCreateManyWithoutSpeakersInput
  interactions: InteractionCreateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserCreatemailErrorsInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  birthdate_ASC
  birthdate_DESC
  role_ASC
  role_DESC
  certified_ASC
  certified_DESC
  gender_ASC
  gender_DESC
  profilePicture_ASC
  profilePicture_DESC
  coverPicture_ASC
  coverPicture_DESC
  bio_ASC
  bio_DESC
  language_ASC
  language_DESC
  theme_ASC
  theme_DESC
  crowned_ASC
  crowned_DESC
  crownedDate_ASC
  crownedDate_DESC
  private_ASC
  private_DESC
  lastConnected_ASC
  lastConnected_DESC
  mailStatus_ASC
  mailStatus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  firstname: String!
  lastname: String!
  email: String!
  password: String!
  birthdate: DateTime!
  role: Role!
  certified: Boolean!
  gender: Gender!
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language!
  theme: Theme!
  crowned: Boolean!
  crownedDate: DateTime
  private: Boolean!
  lastConnected: DateTime
  mailStatus: MailStatus!
  mailErrors: [Int!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  certified: Boolean
  certified_not: Boolean
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  profilePicture: String
  profilePicture_not: String
  profilePicture_in: [String!]
  profilePicture_not_in: [String!]
  profilePicture_lt: String
  profilePicture_lte: String
  profilePicture_gt: String
  profilePicture_gte: String
  profilePicture_contains: String
  profilePicture_not_contains: String
  profilePicture_starts_with: String
  profilePicture_not_starts_with: String
  profilePicture_ends_with: String
  profilePicture_not_ends_with: String
  coverPicture: String
  coverPicture_not: String
  coverPicture_in: [String!]
  coverPicture_not_in: [String!]
  coverPicture_lt: String
  coverPicture_lte: String
  coverPicture_gt: String
  coverPicture_gte: String
  coverPicture_contains: String
  coverPicture_not_contains: String
  coverPicture_starts_with: String
  coverPicture_not_starts_with: String
  coverPicture_ends_with: String
  coverPicture_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  language: Language
  language_not: Language
  language_in: [Language!]
  language_not_in: [Language!]
  theme: Theme
  theme_not: Theme
  theme_in: [Theme!]
  theme_not_in: [Theme!]
  crowned: Boolean
  crowned_not: Boolean
  crownedDate: DateTime
  crownedDate_not: DateTime
  crownedDate_in: [DateTime!]
  crownedDate_not_in: [DateTime!]
  crownedDate_lt: DateTime
  crownedDate_lte: DateTime
  crownedDate_gt: DateTime
  crownedDate_gte: DateTime
  private: Boolean
  private_not: Boolean
  lastConnected: DateTime
  lastConnected_not: DateTime
  lastConnected_in: [DateTime!]
  lastConnected_not_in: [DateTime!]
  lastConnected_lt: DateTime
  lastConnected_lte: DateTime
  lastConnected_gt: DateTime
  lastConnected_gte: DateTime
  mailStatus: MailStatus
  mailStatus_not: MailStatus
  mailStatus_in: [MailStatus!]
  mailStatus_not_in: [MailStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdatemailErrorsInput {
  set: [Int!]
}

input UserUpdateManyDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateManyWithoutBlockedInput {
  create: [UserCreateWithoutBlockedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutBlockedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutBlockedInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutBlockingInput {
  create: [UserCreateWithoutBlockingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutBlockingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutBlockingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutConversationsInput {
  create: [UserCreateWithoutConversationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutConversationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutConversationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutFollowersInput {
  create: [UserCreateWithoutFollowersInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowersInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowersInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutFollowingInput {
  create: [UserCreateWithoutFollowingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutNotificationsInput {
  create: [UserCreateWithoutNotificationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutNotificationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutNotificationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutInteractionsInput {
  create: UserCreateWithoutInteractionsInput
  update: UserUpdateWithoutInteractionsDataInput
  upsert: UserUpsertWithoutInteractionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutTrophiesInput {
  create: UserCreateWithoutTrophiesInput
  update: UserUpdateWithoutTrophiesDataInput
  upsert: UserUpsertWithoutTrophiesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutDebatesBlueInput {
  create: UserCreateWithoutDebatesBlueInput
  update: UserUpdateWithoutDebatesBlueDataInput
  upsert: UserUpsertWithoutDebatesBlueInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutDebatesInput {
  create: UserCreateWithoutDebatesInput
  update: UserUpdateWithoutDebatesDataInput
  upsert: UserUpsertWithoutDebatesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutDebatesRedInput {
  create: UserCreateWithoutDebatesRedInput
  update: UserUpdateWithoutDebatesRedDataInput
  upsert: UserUpsertWithoutDebatesRedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBlockedDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutBlockingDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutConversationsDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutDebatesBlueDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutDebatesDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutDebatesRedDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutFollowersDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutFollowingDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutInteractionsDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutNotificationsDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  trophies: TrophyUpdateManyWithoutUserInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithoutTrophiesDataInput {
  firstname: String
  lastname: String
  email: String
  password: String
  birthdate: DateTime
  role: Role
  certified: Boolean
  gender: Gender
  profilePicture: String
  coverPicture: String
  bio: String
  language: Language
  theme: Theme
  crowned: Boolean
  crownedDate: DateTime
  private: Boolean
  lastConnected: DateTime
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  blocked: UserUpdateManyWithoutBlockingInput
  blocking: UserUpdateManyWithoutBlockedInput
  debates: DebateUpdateManyWithoutOwnerInput
  debatesBlue: DebateUpdateManyWithoutOwnerBlueInput
  debatesRed: DebateUpdateManyWithoutOwnerRedInput
  notifications: NotificationUpdateManyWithoutWhoInput
  conversations: ConversationUpdateManyWithoutSpeakersInput
  interactions: InteractionUpdateManyWithoutWhoInput
  mailStatus: MailStatus
  mailErrors: UserUpdatemailErrorsInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutBlockedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutBlockedDataInput!
}

input UserUpdateWithWhereUniqueWithoutBlockingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutBlockingDataInput!
}

input UserUpdateWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutConversationsDataInput!
}

input UserUpdateWithWhereUniqueWithoutFollowersInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFollowersDataInput!
}

input UserUpdateWithWhereUniqueWithoutFollowingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFollowingDataInput!
}

input UserUpdateWithWhereUniqueWithoutNotificationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutNotificationsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutDebatesBlueInput {
  update: UserUpdateWithoutDebatesBlueDataInput!
  create: UserCreateWithoutDebatesBlueInput!
}

input UserUpsertWithoutDebatesInput {
  update: UserUpdateWithoutDebatesDataInput!
  create: UserCreateWithoutDebatesInput!
}

input UserUpsertWithoutDebatesRedInput {
  update: UserUpdateWithoutDebatesRedDataInput!
  create: UserCreateWithoutDebatesRedInput!
}

input UserUpsertWithoutInteractionsInput {
  update: UserUpdateWithoutInteractionsDataInput!
  create: UserCreateWithoutInteractionsInput!
}

input UserUpsertWithoutTrophiesInput {
  update: UserUpdateWithoutTrophiesDataInput!
  create: UserCreateWithoutTrophiesInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutBlockedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutBlockedDataInput!
  create: UserCreateWithoutBlockedInput!
}

input UserUpsertWithWhereUniqueWithoutBlockingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutBlockingDataInput!
  create: UserCreateWithoutBlockingInput!
}

input UserUpsertWithWhereUniqueWithoutConversationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutConversationsDataInput!
  create: UserCreateWithoutConversationsInput!
}

input UserUpsertWithWhereUniqueWithoutFollowersInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFollowersDataInput!
  create: UserCreateWithoutFollowersInput!
}

input UserUpsertWithWhereUniqueWithoutFollowingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFollowingDataInput!
  create: UserCreateWithoutFollowingInput!
}

input UserUpsertWithWhereUniqueWithoutNotificationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutNotificationsDataInput!
  create: UserCreateWithoutNotificationsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  certified: Boolean
  certified_not: Boolean
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  profilePicture: String
  profilePicture_not: String
  profilePicture_in: [String!]
  profilePicture_not_in: [String!]
  profilePicture_lt: String
  profilePicture_lte: String
  profilePicture_gt: String
  profilePicture_gte: String
  profilePicture_contains: String
  profilePicture_not_contains: String
  profilePicture_starts_with: String
  profilePicture_not_starts_with: String
  profilePicture_ends_with: String
  profilePicture_not_ends_with: String
  coverPicture: String
  coverPicture_not: String
  coverPicture_in: [String!]
  coverPicture_not_in: [String!]
  coverPicture_lt: String
  coverPicture_lte: String
  coverPicture_gt: String
  coverPicture_gte: String
  coverPicture_contains: String
  coverPicture_not_contains: String
  coverPicture_starts_with: String
  coverPicture_not_starts_with: String
  coverPicture_ends_with: String
  coverPicture_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  language: Language
  language_not: Language
  language_in: [Language!]
  language_not_in: [Language!]
  theme: Theme
  theme_not: Theme
  theme_in: [Theme!]
  theme_not_in: [Theme!]
  crowned: Boolean
  crowned_not: Boolean
  crownedDate: DateTime
  crownedDate_not: DateTime
  crownedDate_in: [DateTime!]
  crownedDate_not_in: [DateTime!]
  crownedDate_lt: DateTime
  crownedDate_lte: DateTime
  crownedDate_gt: DateTime
  crownedDate_gte: DateTime
  private: Boolean
  private_not: Boolean
  lastConnected: DateTime
  lastConnected_not: DateTime
  lastConnected_in: [DateTime!]
  lastConnected_not_in: [DateTime!]
  lastConnected_lt: DateTime
  lastConnected_lte: DateTime
  lastConnected_gt: DateTime
  lastConnected_gte: DateTime
  followers_some: UserWhereInput
  following_some: UserWhereInput
  blocked_some: UserWhereInput
  blocking_some: UserWhereInput
  debates_some: DebateWhereInput
  debatesBlue_some: DebateWhereInput
  debatesRed_some: DebateWhereInput
  notifications_some: NotificationWhereInput
  trophies_some: TrophyWhereInput
  conversations_some: ConversationWhereInput
  interactions_some: InteractionWhereInput
  mailStatus: MailStatus
  mailStatus_not: MailStatus
  mailStatus_in: [MailStatus!]
  mailStatus_not_in: [MailStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    